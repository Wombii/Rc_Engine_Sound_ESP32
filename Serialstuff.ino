const int32_t numChars = 256;
char receivedChars[numChars];
//
// =======================================================================================================
// READ SERIAL COMMMANDS 
// =======================================================================================================
// 

void readSerialCommands2() {
  static unsigned long lastSerialRcv;
  static boolean recvInProgress = false;
  static byte index = 0;
  char startMarker = '<'; // Indicates the begin of our data
  char endMarker = '>'; // Indicates the end of our data
  char currentChar; // The currently read character

  //if (millis() - lastSerialRcv > 300) failSafe = true; // Set failsafe mode, if serial command watchdog was triggered
  //else failSafe = false;

  if (Serial.available() > 0) {
    currentChar = Serial.read();
    //lastSerialRcv = millis();

    if (recvInProgress == true) {
      if (currentChar != endMarker) { // End marker not yet detected
        receivedChars[index] = currentChar;
        //Serial.println(currentChar);
        index++;
        if (index >= numChars) {
          index = numChars - 1;
        }
      }
      else { // End marker detected
        receivedChars[index] = '\0'; // terminate the string, if end marker detected
        recvInProgress = false;
        index = 0;
        //Serial.println("processing");
        parseSerialCommands2(); // Call parsing sub function
      }
    }

    if (currentChar == startMarker) { // Start marker detected
      recvInProgress = true;
    }
  }

  // Falisafe for RC signals
  //failsafeRcSignals();

}

// Parsing sub function ----
void parseSerialCommands2() { // - modified Wombii

  char * strtokIindex;
  char delimiter[2] = ","; // used to separate the variables (generated by "println" on the receiver)

  // split the data into its parts
  // order see "sendSerialCommands()" in Micro RC Receiver code: https://github.com/TheDIYGuy999/Micro_RC_Receiver

/*
static unsigned long lastSerialTime;

// '\n' is used as delimiter (separator of variables) during parsing on the sound controller
// it is generated by the "println" (print line) command!
// See: https://github.com/TheDIYGuy999/Rc_Engine_Sound_ESP32

  if (serialCommands) { // only, if we are in serial command mode
    if (millis() - lastSerialTime > 20) { // Send the data every 20ms
      lastSerialTime = millis();
      Serial.print('<'); // Start marker
      Serial.println(data.axis1);
      Serial.println(data.axis2);
      Serial.println(data.axis3);
      Serial.println(data.axis4);
      Serial.println(data.pot1);
      Serial.println(data.mode1);
      Serial.println(data.mode2);
      Serial.println(data.momentary1);     
      Serial.println(hazard);
      Serial.println(left);
      Serial.println(right);
      Serial.print('>'); // End marker
    }
  }*/



  //Expected input:

  // <0,1500,1,1,1> 
  // 0, throttle, siren, horn, ignition

  // <1,1500,10,10,1900,0,1>
  // 1, throttleCenter, neutralUpperOffset, neutralLowerOffset, throttleFull, throttleAxisReversed, reverseType2

  byte modeSelect;
  int xthrottleCenter;
  int xthrottleUpperNeutral;
  int xthrottleLowerNeutral;
  int xthrottleMax;
  int xthrottleReversed;
  int xreverseType2;
  
  strtokIindex = strtok(receivedChars, delimiter);
  modeSelect = atoi(strtokIindex);

  switch(modeSelect)
  {
    case 0: //normal
      strtokIindex = strtok(NULL, delimiter);
      throttleAxis = atoi(strtokIindex);
      strtokIindex = strtok(NULL, delimiter);
      sirenAxis = atoi(strtokIindex);
      strtokIindex = strtok(NULL, delimiter);
      hornAxis = atoi(strtokIindex);
      strtokIindex = strtok(NULL, delimiter);
      ignitionAxis = atoi(strtokIindex);
    break;

    case 1: //config
      strtokIindex = strtok(NULL, delimiter);
      xthrottleCenter = atoi(strtokIindex);
      strtokIindex = strtok(NULL, delimiter);
      xthrottleUpperNeutral = atoi(strtokIindex);
      strtokIindex = strtok(NULL, delimiter);
      xthrottleLowerNeutral = atoi(strtokIindex);
      strtokIindex = strtok(NULL, delimiter);
      xthrottleMax = atoi(strtokIindex);
      strtokIindex = strtok(NULL, delimiter);
      xthrottleReversed = atoi(strtokIindex);
      strtokIindex = strtok(NULL, delimiter);
      xreverseType2 = atoi(strtokIindex);

    break;
    
  }
  //Serial.println(xthrottleCenter);
  //Check if received values are within expected parameters
  if (xthrottleCenter > 1000 && xthrottleCenter < 2000 ) {
    //Serial.println("1");
    if (xthrottleUpperNeutral > 0 && xthrottleUpperNeutral < 200 ) {
      //Serial.println("2");
      if (xthrottleLowerNeutral > 0 && xthrottleLowerNeutral < 200 ) {
        //Serial.println("3");
        if (xthrottleMax > 800 && xthrottleMax < 2200 ) {
          //Serial.println("4");
          if (xthrottleReversed == 0 || xthrottleReversed == 1 ) {
            //Serial.println("5");
            if (xreverseType2 == 0 || xreverseType2 == 1 ) {

              //<1,1500,50,50,1900,1,1>
              throttleCenter = xthrottleCenter;
              neutralUpperOffset = xthrottleUpperNeutral;
              neutralLowerOffset = xthrottleLowerNeutral;
              throttleFull = xthrottleMax;
              throttleAxisReversed = xthrottleReversed;
              reverseType2 = xreverseType2;
              Serial.println("rxed:");
              Serial.printf("center:%d  upper:%d  lower:%d  full:%d  reversed:%d revtype:%d\n",xthrottleCenter,xthrottleUpperNeutral,xthrottleLowerNeutral,xthrottleMax,xthrottleReversed,xreverseType2);
              SavePreferences();
              Serial.println("saved:");
              Serial.printf("center:%d  upper:%d  lower:%d  full:%d  reversed:%d revtype:%d\n",throttleCenter,neutralUpperOffset,neutralLowerOffset,throttleFull,throttleAxisReversed,reverseType2);
              //ReadSavedPreferences();
            }
          }
        }
      }
    }
  }
  

  Serial.print(throttleAxis);
  Serial.print('\t');
  Serial.print(sirenAxis);
  Serial.print('\t');
  Serial.print(hornAxis);
  Serial.print('\t');
  Serial.println(ignitionAxis);

  // Convert signals to servo pulses in ms
  //pulseWidth[0] = map(axis1, 0, 100, 1000, 2000); // CH1 Steering
  //pulseWidth[1] = map(axis2, 0, 100, 1000, 2000); // CH2
  //pulseWidth[2] = map(axis3, 0, 100, 1000, 2000); // CH3 Throttle
  //pulseWidth[3] = map(pot1, 0, 100, 1000, 2000); // Pot1 Horn

  // Invert RC signals
  //invertRcSignals();

  serialInit = true; // first serial data block was processed
}

/*
//
// =======================================================================================================
// READ SERIAL COMMMANDS (only compatible with my "Micro RC" receiver)
// =======================================================================================================
// See: https://github.com/TheDIYGuy999/Micro_RC_Receiver
//      https://forum.arduino.cc/index.php?topic=288234.0


void readSerialCommands() {
  static unsigned long lastSerialRcv;
  static boolean recvInProgress = false;
  static byte index = 0;
  char startMarker = '<'; // Indicates the begin of our data
  char endMarker = '>'; // Indicates the end of our data
  char currentChar; // The currently read character

  if (millis() - lastSerialRcv > 300) failSafe = true; // Set failsafe mode, if serial command watchdog was triggered
  else failSafe = false;

  if (Serial2.available() > 0) {
    currentChar = Serial2.read();
    lastSerialRcv = millis();

    if (recvInProgress == true) {
      if (currentChar != endMarker) { // End marker not yet detected
        receivedChars[index] = currentChar;
        index++;
        if (index >= numChars) {
          index = numChars - 1;
        }
      }
      else { // End marker detected
        receivedChars[index] = '\0'; // terminate the string, if end marker detected
        recvInProgress = false;
        index = 0;
        parseSerialCommands(); // Call parsing sub function
      }
    }

    if (currentChar == startMarker) { // Start marker detected
      recvInProgress = true;
    }
  }

  // Falisafe for RC signals
  failsafeRcSignals();

}

// Parsing sub function ----
void parseSerialCommands() {

  char * strtokIindex;
  char delimiter[2] = "\n"; // used to separate the variables (generated by "println" on the receiver)

  // split the data into its parts
  // order see "sendSerialCommands()" in Micro RC Receiver code: https://github.com/TheDIYGuy999/Micro_RC_Receiver
  strtokIindex = strtok(receivedChars, delimiter);
  axis1 = atoi(strtokIindex);
  strtokIindex = strtok(NULL, delimiter);
  axis2 = atoi(strtokIindex);
  strtokIindex = strtok(NULL, delimiter);
  axis3 = atoi(strtokIindex);
  strtokIindex = strtok(NULL, delimiter);
  axis4 = atoi(strtokIindex);
  strtokIindex = strtok(NULL, delimiter);
  pot1 = atoi(strtokIindex);
  strtokIindex = strtok(NULL, delimiter);
  mode1 = atoi(strtokIindex);
  strtokIindex = strtok(NULL, delimiter);
  mode2 = atoi(strtokIindex);
  strtokIindex = strtok(NULL, delimiter);
  momentary1 = atoi(strtokIindex);
  strtokIindex = strtok(NULL, delimiter);
  hazard = atoi(strtokIindex);
  strtokIindex = strtok(NULL, delimiter);
  left = atoi(strtokIindex);
  strtokIindex = strtok(NULL, delimiter);
  right = atoi(strtokIindex);

  // Convert signals to servo pulses in ms
  pulseWidth[0] = map(axis1, 0, 100, 1000, 2000); // CH1 Steering
  pulseWidth[1] = map(axis2, 0, 100, 1000, 2000); // CH2
  pulseWidth[2] = map(axis3, 0, 100, 1000, 2000); // CH3 Throttle
  pulseWidth[3] = map(pot1, 0, 100, 1000, 2000); // Pot1 Horn

  // Invert RC signals
  invertRcSignals();

  serialInit = true; // first serial data block was processed
}


//
// =======================================================================================================
// PRINT SERIAL DATA
// =======================================================================================================
//

void showParsedData() {
  static unsigned long lastSerialTime;
#ifdef SERIAL_DEBUG
  if (millis() - lastSerialTime > 300) { // Print the data every 300ms
    lastSerialTime = millis();
    Serial.print("axis 1 ");
    Serial.print('\t');
    Serial.println(axis1);
    Serial.print("axis 2 ");
    Serial.print('\t');
    Serial.println(axis2);
    Serial.print("axis 3 ");
    Serial.print('\t');
    Serial.println(axis3);
    Serial.print("axis 4 ");
    Serial.print('\t');
    Serial.println(axis4);
    Serial.print("pot 1 ");
    Serial.print('\t');
    Serial.println(pot1);
    Serial.print("mode 1 ");
    Serial.print('\t');
    Serial.println(mode1);
    Serial.print("mode 2 ");
    Serial.print('\t');
    Serial.println(mode2);
    Serial.print("momenrary 1 ");
    Serial.print('\t');
    Serial.println(momentary1);
    Serial.print("hazard ");
    Serial.print('\t');
    Serial.println(hazard);
    Serial.print("left ");
    Serial.print('\t');
    Serial.println(left);
    Serial.print("right ");
    Serial.print('\t');
    Serial.println(right);
    Serial.print("loop time ");
    Serial.print('\t');
    Serial.println(loopTime);
    Serial.println("");
  }
#endif
}*/
